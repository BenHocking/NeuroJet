# In: Block.Phase - The current block phase. For display purposes only.
#     Block.Number - The current block number. For display purposes only.
#     Block.NumOuterLoops - The number of sub-blocks in this block
#                           (see below) if deterministic; else the total
#                           number of trials
#     Block.RandomChoice - If set to zero, sub-blocks are deterministic;
#                          else, sub-blocks are chosen randomly and
#                          Block.RandomChoice represents the number of choices
#
# Within each block are sub-blocks (represented by "#" below). As an example of
# sub-blocks, consider the TP paradigm with progressive learning. For block 5,
# the animal is trained on 5 trials of AB, 20 trials of BC, and then 5 more
# trials of AB. Therefore, there are 3 sub-blocks. For random training, the
# sub-blocks represent different possible choices of testing/training
# combinations.
#
# In: Block.Sub#.NumInnerLoops - For deterministic training, this is the number
#                                of trials per sub-block. For random training,
#                                this becomes a count of the number of
#                                instances of each sub-block experienced.
#     Block.Sub#.TestSequence - The name of the test sequence to use in the
#                               decision function. If the decision
#                               function is Decision.nj, this sequence
#                               should omit the trailing "test". If
#                               the decision function is DecisionP.nj,
#                               "correct" and "wrong" are omitted.
#     Block.Sub#.PlusSequence - The name of the traning sequence to use when a
#                               correct choice is made.
#     Block.Sub#.MinusSequence - The name of the traning sequence to use when
#                                an incorrect choice is made.
#     Block.Sub#.SimSequence - The name of the sequence that contains the
#                              correct pattern in the first part of the
#                              sequence, and the incorrect pattern in the
#                              second part of the sequence.
#     Block.Sub#.SuccessMeasure - The name of the success measure to update
#                                 with the results of the block of trials.
#
# Out: ^(Block.Sub#.SuccessMeasure) - That ^() is very deliberate here. We are
#                                     NOT modifying Block.Sub#.SuccessMeasure,
#                                     rather we are modifying the variable it
#                                     refers to (e.g., ABsucc).
#      Block.Sub#.MeasureCount - The total number of times this
#                                     stimulus was presented

?If(^(Block.Phase) > 0) {
  @Print( "++++ Phase " ^(Block.Phase) " ++++\n" )
}
?If(exists[Block.Number]) {
  @Print( "++++ Block " ^(Block.Number) " ++++\n" )
}

# This needs to be done outside the bigger loop because inner loops might have
# the same measure!
@SetVar(Block.NumLoops ^(Block.NumOuterLoops))
?If(^(Block.RandomChoice) > 0) {
  @SetVar(Block.NumLoops ^(Block.RandomChoice))
}

# Setting up to measure success and normalization
%(Block.OuterLoop 1 ^(Block.NumLoops)) {
  @SetVar(^(Block.Sub:^(Block.OuterLoop):.SuccessMeasure) 0)
  # If RandomChoice, NumInnerLoops is used to track instances of each choice
  ?If(^(Block.RandomChoice) > 0) {
    @SetVar(Block.Sub:^(Block.OuterLoop):.NumInnerLoops 0)
  }
}

%(Block.OuterLoop 1 ^(Block.NumOuterLoops)) {
  ?If(^(Block.RandomChoice) = 0) {
    @SetVar(
      Block.Cur.Seq           ^(Block.OuterLoop)
      Block.Cur.NumInnerLoops ^(Block.Sub:^(Block.OuterLoop):.NumInnerLoops)
    )
  }
  ?If(^(Block.RandomChoice) > 0) {
    # Pick a number between 1 and Block.RandomChoice
    @SetVar(Block.Cur.Seq ^Calc(randint[1, ^(Block.RandomChoice)]))
    @SetVar(
      Block.Sub:^(Block.Cur.Seq):.NumInnerLoops
        ^Calc(^(Block.Sub:^(Block.Cur.Seq):.NumInnerLoops) + 1)
      Block.Cur.NumInnerLoops  1
    )
  }
  # If this is not the same sequence as the last sub-block, then we
  # do not want to bias the decision just becase the last decision was
  # wrong. The sequences might be the same either due to RandomChoice,
  # or due to the last sub-block in one block matching the first
  # sub-block in the next block.
  ?If (strcmp[^(Block.Sub:^(Block.Cur.Seq):.TestSequence), ^(Block.LastTestSequence)]) {
    # Set last decision to be correct to NOT bias decision (WARNING: This
    # might be decision-rule specific!)
    @SetVar(^(DecisionFn):.Correct 1)
    @SetVar(Block.LastTestSequence ^(Block.Sub:^(Block.Cur.Seq):.TestSequence))
  }
  %(Block.Loop 1 ^(Block.Cur.NumInnerLoops)) {
    ?If (~strcmp[^(DecisionFn), Decision] | ~strcmp[^(DecisionFn), Decision4] |
         ~strcmp[^(DecisionFn), DecisionComplex]) {
      @SetVar(
        ^(DecisionFn):.TestSequence ^(Block.Sub:^(Block.Cur.Seq):.TestSequence):test
        ^(DecisionFn):.SimSequence ^(Block.Sub:^(Block.Cur.Seq):.SimSequence)
      )
    }
    ?If (~strcmp[^(DecisionFn), DecisionP]) {
      @SetVar(
        ^(DecisionFn):.TestSequence ^(Block.Sub:^(Block.Cur.Seq):.TestSequence)
        ^(DecisionFn):.TestCorrect ^(Block.Sub:^(Block.Cur.Seq):.TestSequence):correct
        ^(DecisionFn):.TestWrong ^(Block.Sub:^(Block.Cur.Seq):.TestSequence):wrong
      )
    }
    ?Read(^(DecisionFn):.nj)
    ?If(exists[^(DecisionFn):.Analysis]) {
      @Analysis(^(DecisionFn):.Analysis)
    }
    # DO NOT assume that PlusSeq and MinusSeq are the same length!
    @MakeRandSequence(-name InitPtn -Nend ^(ni) -len ^(Period) -p ^Calc(^(Activity) * 0.3))
    @Test(-name InitPtn -time ^SequenceLength(-from InitPtn) -nocomp -norecord 7 TestingThresholds TestingBusLines TestingIntBusLines TestingKWeights TestingInhibitions TestingFBInternrnExc TestingFFInternrnExc)
    ?If (~exists[saveReset]) { @CreateVar(saveReset 0) }
    @SetVar(saveReset ^(Reset))
    @SetVar(Reset 0)
    ?If (^(^(DecisionFn):.Correct) = 1) {
      # A word about ^(^(Block.Sub:^(Block.Cur.Seq):.SuccessMeasure):
      #   ^(Block.Cur.Seq) is a number so Block.Sub:^(Block.Cur.Seq):.SuccessMeasure
      #   could be, e.g., Block.1.SuccessMeasure. In turn, this corresponds
      #   to another variable, so that ^(Block.1.SuccessMeasure) might
      #   reference the variable ABp, for example. In this extended example,
      #   ^(^(Block.Sub:^(Block.Cur.Seq):.SuccessMeasure) could therefore be
      #   the equivalent of simply ^(ABp).
      @SetVar(^(Block.Sub:^(Block.Cur.Seq):.SuccessMeasure)
                ^Calc(^(^(Block.Sub:^(Block.Cur.Seq):.SuccessMeasure))+1))
      ?If(exists[Setme.OnNoiseProb]) {
        @MakeRandSequence(-name OnNoise -p ^(Setme.OnNoiseProb) -len ^SequenceLength(-from ^(Block.Sub:^(Block.Cur.Seq):.PlusSequence)))
        @CombineData(-to trnSeq -from 2 ^(Block.Sub:^(Block.Cur.Seq):.PlusSequence) OnNoise)
        @SetVar(Block.TestSequence trnSeq)
      }
      ?If(~exists[Setme.OnNoiseProb]) {
        @SetVar(Block.TestSequence ^(Block.Sub:^(Block.Cur.Seq):.PlusSequence))
      }
    }
    ?If (^(^(DecisionFn):.Correct) = 0) {
      ?If(exists[Setme.OnNoiseProb]) {
        @MakeRandSequence(-name OnNoise -p ^(Setme.OnNoiseProb) -len ^SequenceLength(-from ^(Block.Sub:^(Block.Cur.Seq):.MinusSequence)))
        @CombineData(-to trnSeq -from 2 ^(Block.Sub:^(Block.Cur.Seq):.MinusSequence) OnNoise)
        @SetVar(Block.TestSequence trnSeq)
      }
      ?If(~exists[Setme.OnNoiseProb]) {
        @SetVar(Block.TestSequence ^(Block.Sub:^(Block.Cur.Seq):.MinusSequence))
      }
    }
    ?If(exists[trnBuffPrefix]) {
      @Train(-name ^(Block.TestSequence) -trials 1 -nocomp -norecord 7 TrainingThresholds TrainingBusLines TrainingIntBusLines TrainingKWeights TrainingInhibitions TrainingFBInternrnExc TrainingFFInternrnExc)
    }
    ?If(~exists[trnBuffPrefix]) {
      @Train(-name ^(Block.TestSequence) -trials 1 -nocomp -norecord 8 TrainingBuffer TrainingThresholds TrainingBusLines TrainingIntBusLines TrainingKWeights TrainingInhibitions TrainingFBInternrnExc TrainingFFInternrnExc)
    }
    @SetVar(Reset ^(saveReset))
    ?If(exists[trnActFileName]) {
      @SaveData(-from TrainingActivity -to ^(trnActFileName) -append)
      @DeleteData(TrainingActivity)
    }
    ?If(exists[trnBuffPrefix]) {
      @SaveData(-from TrainingBuffer -to ^(trnBuffPrefix):^(TrainingCount):.dat)
      @DeleteData(TrainingBuffer)
    }
    @PrintVar(AveTrainAct Activity)
    # A variation on Sean's rule (but not actually Sean's rule)
    @SetVar(
      KFB ^Calc(^(KFB) + [0.05 * ^(KFB) * [^(AveTrainAct)-^(Activity)]/ ^(Activity)])
    )
    @PrintVar(KFB)
  }
}

# Adjusting Success Measures...
@SetVar(Block.NumLoops ^(Block.NumOuterLoops))
?If(^(Block.RandomChoice) > 0) {
  @SetVar(Block.NumLoops ^(Block.RandomChoice))
}
%(Block.OuterLoop 1 ^(Block.NumLoops)) {
  # We don't want to normalize the measure twice!
  @SetVar(Block.MeasureFound 0)
  ?If(^(Block.OuterLoop) > 1) {
    %(Block.CheckLoop 1 ^Calc(^(Block.OuterLoop)-1)) {
      # If this measure matches an earlier measure...
      ?If(~strcmp[^(Block.Sub:^(Block.OuterLoop):.SuccessMeasure),
                    ^(Block.Sub:^(Block.CheckLoop):.SuccessMeasure)]) {
        @SetVar(Block.MeasureFound 1)
      }
    }
  }
  # Count the total number of times this measure was made
  ?If(~exists[Block.Sub:^(Block.OuterLoop):.MeasureCount]) {
    @CreateVar(Block.Sub:^(Block.OuterLoop):.MeasureCount 0)
  }
  @SetVar(Block.Sub:^(Block.OuterLoop):.MeasureCount ^(Block.Sub:^(Block.OuterLoop):.NumInnerLoops))
  ?If(^(Block.OuterLoop) < ^(Block.NumLoops)) {
    %(Block.CountLoop ^Calc(^(Block.OuterLoop)+1) ^(Block.NumLoops)) {
      # If this measure matches a later measure...
      ?If(~strcmp[^(Block.Sub:^(Block.OuterLoop):.SuccessMeasure),
                    ^(Block.Sub:^(Block.CountLoop):.SuccessMeasure)]) {
        @SetVar(Block.Sub:^(Block.OuterLoop):.MeasureCount
          ^Calc(^(Block.Sub:^(Block.OuterLoop):.MeasureCount)+^(Block.Sub:^(Block.CountLoop):.NumInnerLoops)))
      }
    }
  }
  # Normalize, if not already done
  ?If(^(Block.MeasureFound) = 0) {
   @SetVar(^(Block.Sub:^(Block.OuterLoop):.SuccessMeasure)
    ^Calc(^(^(Block.Sub:^(Block.OuterLoop):.SuccessMeasure))*100/^(Block.Sub:^(Block.OuterLoop):.MeasureCount)))
  }
}
